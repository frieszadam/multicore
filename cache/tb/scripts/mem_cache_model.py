"""
Cache and Memory Software Models
Used to predict expected results, including read data and
memory requests from the cache.
GENERATED BY CHATGPT
"""

import re
from hardware_interface import *
import math

class MemoryModel:
    """A byte-addressable model for main memory."""
    def __init__(self, size_bytes=2**16):
        self.size = size_bytes
        self.memory = {} # Dictionary to store bytes
        print(f"Initialized Memory Model with {self.size} bytes.")

    def read(self, address):
        """Reads a 32-bit word from a given address."""
        base_addr = address & ~0b11 # Align to word boundary
        word = 0
        for i in range(4):
            byte = self.memory.get(base_addr + i, 0)
            word |= (byte << (i * 8))
        return word

    def write(self, address, data, byte_enable=0b1111):
        """Writes up to a 32-bit word to a given address based on byte_enable."""
        base_addr = address & ~0b11 # Align to word boundary
        if (byte_enable >> 0) & 1: self.memory[base_addr + 0] = (data >> 0) & 0xFF
        if (byte_enable >> 1) & 1: self.memory[base_addr + 1] = (data >> 8) & 0xFF
        if (byte_enable >> 2) & 1: self.memory[base_addr + 2] = (data >> 16) & 0xFF
        if (byte_enable >> 3) & 1: self.memory[base_addr + 3] = (data >> 24) & 0xFF

class CacheModel:
    """A model for an N-way set-associative cache with LRU replacement."""
    def __init__(self, cache_size_bytes, block_size_bytes, num_ways):
        # Cache configuration
        self.cache_size = cache_size_bytes
        self.block_size = block_size_bytes
        self.num_ways = num_ways
        self.num_sets = cache_size_bytes // (block_size_bytes * num_ways)

        # Calculate address bit breakdowns
        self.offset_bits = int(math.log2(block_size_bytes))
        self.index_bits = int(math.log2(self.num_sets))
        self.tag_bits = 32 - self.index_bits - self.offset_bits

        # Data structure for the cache
        line_template = {'meta': {'valid': False, 'dirty': False, 'tag': 0}, 'lru': 0, 'data': [0]* (block_size_bytes // 4)}
        self.sets = [[line_template.copy() for _ in range(num_ways)] for _ in range(self.num_sets)]
        
        self.memory_model = MemoryModel()

        print(f"Initialized {self.num_ways}-Way Set-Associative Cache Model:")
        print(f"  - Size: {self.cache_size} bytes, Block Size: {self.block_size} bytes")
        print(f"  - Sets: {self.num_sets}, Ways: {self.num_ways}")
        print(f"  - Address bits -> Tag: {self.tag_bits}, Index: {self.index_bits}, Offset: {self.offset_bits}")

    # --- Internal Helper Methods ---

    def _get_address_parts(self, address):
        """Helper to break down an address into tag, index, and offset."""
        address = address & ~0b11
        offset = address & ((1 << self.offset_bits) - 1)
        index = (address >> self.offset_bits) & ((1 << self.index_bits) - 1)
        tag = address >> (self.offset_bits + self.index_bits)
        return tag, index, offset
        
    def _update_lru(self, set_index, touched_way_index):
        """Updates LRU counters for a given set after an access."""
        touched_lru_val = self.sets[set_index][touched_way_index]['lru']
        for way in self.sets[set_index]:
            if way['lru'] > touched_lru_val:
                way['lru'] -= 1
        self.sets[set_index][touched_way_index]['lru'] = self.num_ways - 1

    def _get_lru_victim_index(self, set_index):
        """Finds the way index of the LRU victim in a set."""
        for i, way in enumerate(self.sets[set_index]):
            if way['lru'] == 0:
                return i
        # This case should not be reached if the set is full and LRU is managed correctly.
        return 0

    def _find_in_set(self, tag, set_index):
        """Searches a set for a given tag. Returns way index or None if miss."""
        for i, way in enumerate(self.sets[set_index]):
            if way['meta']['valid'] and way['meta']['tag'] == tag:
                return i
        return None

    def _handle_miss(self, address, tag, index):
        """
        Handles miss logic and returns a list of expected memory events.
        """
        expected_events = []
        # Find an invalid line first. If none, find the LRU victim.
        victim_way_idx = self._find_in_set(None, index)
        if victim_way_idx is None:
            victim_way_idx = self._get_lru_victim_index(index)
        
        victim_way = self.sets[index][victim_way_idx]

        # If the chosen victim line is valid and dirty, it must be written back.
        if victim_way['meta']['valid'] and victim_way['meta']['dirty']:
            print("    - Evicting dirty block.")
            old_tag = victim_way['meta']['tag']
            evict_address = (old_tag << (self.index_bits + self.offset_bits)) | (index << self.offset_bits)
            for i, word in enumerate(victim_way['data']):
                self.memory_model.write(evict_address + i*4, word)
            expected_events.append({'type': 'expect_mem_write', 'addr': evict_address})
            expected_events.append({'type': 'wait', 'cycles': 100})

        # Fetch the required block from memory.
        block_start_address = address & ~(self.block_size - 1)
        print(f"    - Fetching block starting at 0x{block_start_address:08X} from memory.")
        expected_events.append({'type': 'expect_mem_read', 'addr': block_start_address})
        expected_events.append({'type': 'wait', 'cycles': 100})

        new_data = [self.memory_model.read(block_start_address + i*4) for i in range(self.block_size // 4)]
        
        # Update the cache line with the new data and metadata.
        victim_way['meta'] = {'valid': True, 'dirty': False, 'tag': tag}
        victim_way['data'] = new_data
        self._update_lru(index, victim_way_idx)

        return expected_events

    # --- Public Inspection Methods ---

    def get_full_sets(self):
        """
        Identifies and returns a list of indices for sets that are full (have no
        invalid lines). An access to a new tag in one of these sets will
        always cause an eviction.
        """
        full_set_indices = []
        for i, current_set in enumerate(self.sets):
            is_full = all(way['meta']['valid'] for way in current_set)
            if is_full:
                full_set_indices.append(i)
        return full_set_indices

    def will_cause_read_miss(self, address):
        """
        Checks if a read to a given address would result in a cache miss
        without changing the state of the cache.
        Returns:
            bool: True if it's a miss, False if it's a hit.
        """
        tag, index, _ = self._get_address_parts(address)
        hit_way_idx = self._find_in_set(tag, index)
        return hit_way_idx is None

    # --- Public Processing Methods ---

    def process_read(self, address):
        tag, index, offset = self._get_address_parts(address)
        print(f"\n---> MODEL: Processing READ from address 0x{address:08X}")
        
        hit_way_idx = self._find_in_set(tag, index)
        expected_events = []

        if hit_way_idx is not None:
            print("  - Outcome: Read HIT")
            self._update_lru(index, hit_way_idx)
            word_offset = offset // 4
            expected_data = self.sets[index][hit_way_idx]['data'][word_offset]
            expected_events.append({'type': 'receive', 'addr': address, 'data': expected_data})
        else:
            print("  - Outcome: Read MISS")
            expected_events.extend(self._handle_miss(address, tag, index))
            word_offset = offset // 4
            # We must find the way again as it might not be the victim if there was an empty slot.
            new_hit_way_idx = self._find_in_set(tag, index)
            expected_data = self.sets[index][new_hit_way_idx]['data'][word_offset]
            expected_events.append({'type': 'receive', 'addr': address, 'data': expected_data})
            
        return expected_events

    def process_write(self, address, data, byte_enable=0b1111):
        tag, index, offset = self._get_address_parts(address)
        print(f"\n---> MODEL: Processing WRITE to address 0x{address:08X}")
        
        hit_way_idx = self._find_in_set(tag, index)
        word_offset = offset // 4
        expected_events = []
        
        if hit_way_idx is not None:
            print("  - Outcome: Write HIT")
            self._update_lru(index, hit_way_idx)
            way_to_write = self.sets[index][hit_way_idx]
        else:
            print("  - Outcome: Write MISS (Write-Allocate)")
            expected_events.extend(self._handle_miss(address, tag, index))
            new_way_idx = self._find_in_set(tag, index)
            way_to_write = self.sets[index][new_way_idx]

        # Update the data in the cache model, respecting the byte enable mask.
        old_word = way_to_write['data'][word_offset]
        mask = 0
        if (byte_enable >> 0) & 1: mask |= 0x000000FF
        if (byte_enable >> 1) & 1: mask |= 0x0000FF00
        if (byte_enable >> 2) & 1: mask |= 0x00FF0000
        if (byte_enable >> 3) & 1: mask |= 0xFF000000
        
        new_word = (old_word & ~mask) | (data & mask)
        way_to_write['data'][word_offset] = new_word
        way_to_write['meta']['dirty'] = True
        
        return expected_events
